
***(%

\subsection{Matching definitional trees}\label{subsec:mdt}

We describe in this section the implementation of the matching
definitional trees.

{\codesize
\begin{verbatim}
%)

fmod LAZY-NAT-LIST is
 pr NAT-LIST . 

 sort LazyNatList .
 ****
 *** LazyNatList: lazy in the second argument of cons
 ****
 op [] : ->  LazyNatList [ctor] .
 op _:_ : Nat LazyNatList ->  LazyNatList [ctor strat (1 0)] .
 op from : Nat -> LazyNatList .
 op take : Nat LazyNatList -> NatList .
 op drop : Nat LazyNatList -> LazyNatList .

 vars I N N' : Nat .
 vars Xs Ys : LazyNatList .

 eq from(N) =  N : from(s(N)) .
 eq take(0, Xs) = nil .
 eq take(s(I), N : Xs) = N take(I, Xs) .
 eq drop(0, Xs) = Xs .
 eq drop(s(I), N : Xs) = drop(I, Xs) .
endfm

view LazyNatList from TRIV to LAZY-NAT-LIST is
  sort Elt to LazyNatList .
endv

fmod MDT is
 pr META-LEVEL .

 sort MDT Forest .
 subsort MDT < Forest .
 sort Branch .

 ****
 *** Matching Definitional Tree constructors
 ****
 op <_,_> : NatList Forest -> Branch .
 op empty : -> Branch .
 op __ : Branch Branch -> Branch [ctor assoc id: empty] .
 
 op leaf : Term Rule -> MDT .
 op or : Forest -> MDT .
 op branch : Term Branch -> MDT .
 op empty : -> Forest .
 op __ : Forest Forest -> Forest [ctor assoc id: empty] .
endfm

view Mdt from TRIV to MDT is
  sort Elt to MDT .
endv

view Branch from TRIV to MDT is
  sort Elt to Branch .
endv

view Forest from TRIV to MDT is
  sort Elt to Forest .
endv

view Term from TRIV to META-TERM is
   sort Elt to Term .
endv

fmod MATCHING-TREE is
 pr META-LEVEL .
 pr MODULE-CONSTRAINTS .
 pr SET{Pos} .
 pr MULTISET{Pos} .
 pr MAP{Qid, Nat} .
 pr CONVERSION .
 pr LAZY-NAT-LIST .
 pr MDT .
 pr PAIR{LazyNatList, Branch} .
 pr PAIR{LazyNatList, Mdt} .
--- pr PAIR{LazyNatList, Forest} .
 --- para simular las parejas
 pr MAP{Forest, LazyNatList} .
 pr PAIR{RuleSet, RuleSet} .
 pr MAP{Qid, Mdt} .
 pr PAIR{LazyNatList, Term} .
--- Using  
--- pr SET{Var} .
--- pr SET{Term} .

 ****
 *** Term manipulation
 ****
 *** returns the signature deduced for a given program
 op signature : RuleSet -> QidSet .
 *** returns the set of constructor symbols deduced for a given program
 op cs : RuleSet -> QidSet .
 *** returns the set of function symbols deduced for a given program
 op fs : RuleSet -> QidSet .
   *** returns the set of elements of the signature that are used in the given term
   op symbols : Term -> QidSet .
   op symbolss : TermList -> QidSet .
 op lhs : Rule -> Term .
 --- for function symbols and constructor symbols present in lhss only!
 op arity : RuleSet -> Map{Qid, Nat} .
 --- set of rules for the given function symbol
 op rulesOf : Qid RuleSet -> RuleSet . 
 op positions : Term -> Set{Pos} .
    op posI : Nat TermList -> Set{Pos} .
    op mapAppendSet : NatList Set{Pos} -> Set{Pos} .
 *** Positions of variables
 op positionsVar : Term -> Set{Pos} .
    op filtPosVar : Term Set{Pos} -> Set{Pos} .
 *** Positions of terms rooted by some element of the signature
 op positionsSigma : Term -> Set{Pos} .
 *** Positions of constructor rooted terms
 op positionsCS : QidSet Term -> Set{Pos} .
    op filtPosCS : QidSet Term Set{Pos} -> Set{Pos} .
 op at : Term NatList -> Term .
 op isPrefix : NatList NatList -> Bool .
 op minimalPos : Set{Pos} -> Set{Pos} .
 
 *** indexing from 0
 op nth : Nat TermList -> Term .
 op root : Term -> Qid .
 op replace : Term NatList Term -> Term .
 op apSubst : Substitution Term -> Term .
 op flatApp : LazyNatList Map{Qid, Nat} Qid -> Pair{LazyNatList, Term} .

 ****
 *** Tree construction
 ****
 op treeVar : Nat -> Variable .
 *** Builds a mapping from any function of the program to its corresponding tree
 op MDTMap : Module -> Map{Qid, Mdt} .
   **** Builds the tree for a given function symbol
 op constructMDTF : Module LazyNatList Map{Qid, Nat} Qid RuleSet -> Pair{LazyNatList, Mdt} .
   **** Builds the tree for a given call pattern
 op constructMDT : Module LazyNatList Map{Qid, Nat} Term RuleSet -> Pair{LazyNatList, Mdt} . 


 op disagreementPos : Term Term -> Set{Pos} .
   op filtDisagree : Term Term Set{Pos} -> Set{Pos} .
 op DPl : QidSet Term Term -> Set{Pos} .
 op DPR : RuleSet Term -> Mset{Pos} .
   op DPRAux : QidSet RuleSet Term -> Mset{Pos} .
 op DPRm : RuleSet Term -> Set{Pos} .
   op filtDPRm : Set{Pos} Set{Pos} Mset{Pos} RuleSet QidSet Term -> Set{Pos} .

 vars Rs Rs' Ss : RuleSet . 
 var  R : Rule .
 vars H F C : Qid .
 vars CS FS : QidSet .
 vars TL TL' : TermList .
 vars T T' Pat Pat' Pat'' Left : Term .
 var  AtS : AttrSet .
 var  Ct : Constant .
 var  V V' : Variable .
 vars I N N' : Nat .
 var O P : NatList .
 var Os Ps : Set{Pos} .
 var Oss Pss : Mset{Pos} .
 vars Ar Ar' : Map{Qid, Nat} .
 vars Xs Ys Xs' Ys' : LazyNatList .
 var Tm : Map{Qid, Mdt} .
 vars Tree Tree' : MDT .
 vars For For' : Forest .
 vars Br Br' : Branch .
 vars Sigma Theta : Substitution .
 var M : Module .

 --- assuming well formed expressions and programs
 --- red symbols('s['z.Exp]) .
 eq symbols(V) = none .
 eq symbols(Ct) = Ct .
 eq symbols(H [ TL ]) = H ; symbolss(TL) .
 eq symbolss(empty) = none .
 eq symbolss((T, TL)) =  symbols(T) ; symbolss(TL) .
 --- red signature(rl 'f['X:Exp] => 'h['X:Exp] [none] .) .
 eq signature(none) = none .
 eq signature((rl T => T' [ AtS ] .) Rs) = symbols(T) ; symbols(T') ; signature(Rs) .
 ---  red fs((rl 'f['X:Exp] => 'h['X:Exp] [none] .) (rl 'h['z.Exp] => 's['z.Exp] [none] .)) .
 eq fs(none) = none .
 eq fs(R Rs) = root(lhs(R)) ; fs(Rs) .
 --- red cs((rl 'f['X:Exp] => 'h['X:Exp] [none] .) (rl 'h['z.Exp] => 's['z.Exp] [none] .)) .
 eq cs(Rs) = signature(Rs) \ fs(Rs) .
 eq lhs(rl T => T' [ AtS ] .) = T .

 --- red arity(( rl 'or['X:Exp,'tt.Exp] => 'tt.Exp [none] .) (rl 'or['ff.Exp,'X:Exp] => 'X:Exp [none] .) (rl 'or['tt.Exp,'X:Exp] => 'tt.Exp [none] .)) .
 eq arity(none) = empty .
--- eq arity(((rl Ct => T' [ AtS ] .) Rs)) = insert(Ct, 0 , arity(Rs)) .
 eq arity(((rl Ct => T' [ AtS ] .) Rs)) = arityAux(T', insert(Ct, 0 , arity(Rs))) .
--- eq arity(((rl (F [ TL ]) => T' [ AtS ] .) Rs)) = arityAux(TL, insert(F , lengthTL(TL) , arity(Rs)) ).
 eq arity(((rl (F [ TL ]) => T' [ AtS ] .) Rs)) = arityAux(T', arityAux(TL, insert(F , lengthTL(TL) , arity(Rs)) )) .
  op arityAux : TermList Map{Qid, Nat} -> Map{Qid, Nat} .
  eq arityAux(empty, Ar) = Ar .
  eq arityAux((T, TL), Ar) = if isVar(T) then arityAux(TL, Ar) 
                                         else insert(root(T), arityTerm(T), arityAux(TL, arityAux(args(T), Ar)))
                             fi .
  op arityTerm : Term -> Nat .
  eq arityTerm(F [ TL ]) = lengthTL(TL) .
  eq arityTerm(T) = 0 [owise] .
  op args : Term -> TermList .
  eq args(V) = empty .
  eq args(Ct) = empty .
  eq args((F [ TL ] )) = TL .
  op lengthTL : TermList -> Nat .
  eq lengthTL(empty) = 0 .
  eq lengthTL((T, TL)) = 1 + lengthTL(TL) .
 eq rulesOf(F, none) = none .
 eq rulesOf(F, (rl Ct => T' [ AtS ] .) Rs) = if F == Ct then (rl Ct => T' [ AtS ] .) else none fi rulesOf(F, Rs) .
 eq rulesOf(F, (rl (H [ TL ]) => T' [ AtS ] .) Rs) = if F == H then (rl (H [ TL ]) => T' [ AtS ] .) else none fi rulesOf(F, Rs) .

  
 --- red mapAppendSet((0 1 nil), ((2 3) , (3 4), empty)) .
 eq mapAppendSet(O, empty) = empty .
 eq mapAppendSet(O, (P, Ps)) = (O P) , mapAppendSet(O, Ps) .
 --- red positions('g['h['X:Exp],'g['f['Y:Exp],'Y:Exp]]) .
 eq positions(V) = nil .
 eq positions(Ct) = nil .
 eq positions(H [ TL ]) = nil , posI(1, TL) .
    eq posI(I, empty) = empty .
    eq posI(I, (T, TL)) = mapAppendSet(I, positions(T)) , posI((I + 1), TL) .
 --- red positionsVar('g['h['X:Exp],'g['f['Y:Exp],'Y:Exp]]) .
 eq positionsVar(T) = filtPosVar(T, positions(T)) .
    eq filtPosVar(T, empty) = empty .
    eq filtPosVar(T, (P, Ps)) = if isVar(at(T, P)) then P  else empty fi , filtPosVar(T, Ps) .
 ---  red positionsCS('h ; 'c ; 'f, 'g['h['X:Exp],'g['f['Y:Exp],'Y:Exp]]) .
 eq positionsCS(CS, T) = filtPosCS(CS, T, positions(T)) .
    eq filtPosCS(CS, T, empty) = empty .
    eq filtPosCS(CS, T, (P, Ps)) = if (root(at(T, P)) in CS) then P  else empty fi , filtPosCS(CS, T, Ps) .
 --- red positionsSigma('g['h['X:Exp],'g['f['Y:Exp],'Y:Exp]]) .
 eq positionsSigma(T) = positions(T) \ positionsVar(T) .


 eq nth(0, (T , TL)) = T . 
 eq nth(s(I), (T, TL)) = nth(I, TL) . 

 eq isPrefix(nil, P) = true .
 eq isPrefix((N O), (N P)) = isPrefix(O, P) .
 eq isPrefix(O,P) = false [owise] .

 eq minimalPos(Os) = minimalPosAux(Os, Os) .
 op minimalPosAux : Set{Pos} Set{Pos} -> Set{Pos} .
 eq minimalPosAux(empty, Ps) = empty .
 eq minimalPosAux((O, Os), Ps) = if minimalIn(O, Ps) then O else empty fi , minimalPosAux(Os, Ps) .
   op minimalIn : NatList Set{Pos} -> Bool .
   eq minimalIn(O, empty) = true .
   eq minimalIn(O, (O, Ps)) = minimalIn(O, Ps) .
   eq minimalIn(O, (P, Ps)) = if isPrefix(P, O) then false else minimalIn(O, Ps) fi [owise] .

 --- red at('g['h['X:Exp],'g['f['Y:Exp],'Y:Exp]], 2 1) .
 eq at(T, nil) = T .
 eq at(H [ TL ], (s(I) P)) = at(nth(I , TL), P) .

 --- red root(at('g['h['X:Exp],'g['f['Y:Exp],'Y:Exp]], 2 1)) .
 eq root(V) = V .
 eq root(Ct) = Ct .
 eq root(H [ TL ]) = H .

 eq replace(T, nil, T') = T' . 
 eq replace(H [ TL ], s(I) O, T') = H [ replaceTL(TL, I, replace(nth(I, TL), O, T')) ] . 
   *** indexing from 0
   op replaceTL : TermList Nat Term -> TermList .
   eq replaceTL((T, TL), 0, T') = T' , TL .
   eq replaceTL((T, TL), s(I), T') = T , replaceTL(TL, I, T') .

 --- red apSubst('X:Exp <- 'tt.Exp ; 'Y:Exp <- 'tt.Exp, 'c ['X:Exp]) .
 eq apSubst(none, T)= T .
 eq apSubst((V <- T) ; Sigma , V') = if V == V' then T else apSubst(Sigma , V') fi .
 eq apSubst(Sigma, Ct) = Ct .
 eq apSubst(Sigma, H [ TL ]) = H [ mapApSubst(Sigma, TL) ] .
  op mapApSubst : Substitution TermList -> TermList .
  eq mapApSubst(Sigma, empty) = empty .
  eq mapApSubst(Sigma, (T, TL)) = apSubst(Sigma, T) , mapApSubst(Sigma, TL) .
  --- Usar nubTL para simular cjtos
  --- For a given set of vars returns the part of the substitution which has its domain contained in that
  --- set and besides has only variables in its range
  op getRenaming : TermList Substitution -> Substitution .
  eq getRenaming(empty, Sigma) = none .   
  eq getRenaming((V, TL), Sigma) = getRenamingVar(V, Sigma) ; getRenaming(TL, Sigma) .
  op getRenamingVar : Variable Substitution -> Substitution .
  eq getRenamingVar(V, none) = none .
  eq getRenamingVar(V, (V <- T) ; Sigma) = if isVar(T) then (V <- T) else none fi .
  eq getRenamingVar(V, Sigma) = none [owise] .

  --- main: en unifyingRules despues de unificar usar reverseRenaming(getVars(Pat), Sigma,  Left), tb con el lado dcho 
  op reverseRenamingTotal : Substitution Term -> Term .
  ceq reverseRenamingTotal(Sigma, T) = apSubst(reverseRenamingAux(Theta), apSubst(Sigma, T))
    if Theta := getRenamingTotal(Sigma) .

  op getRenamingTotal : Substitution -> Substitution .
  eq getRenamingTotal(none) = none .
  eq getRenamingTotal((V <- T) ; Sigma) = if isVar(T) then (V <- T) else none fi ; getRenamingTotal(Sigma) .

  op reverseRenaming : TermList Substitution Term -> Term .
  ceq reverseRenaming(TL, Sigma, T) = apSubst(reverseRenamingAux(Theta), apSubst(Sigma, T))
    if Theta := getRenaming(nubTL(TL), Sigma) .
  op reverseRenamingAux : Substitution -> Substitution .
  eq reverseRenamingAux(none) = none .
  eq reverseRenamingAux((V <- V') ; Sigma) = (V' <- V) ; reverseRenamingAux(Sigma) .

 eq flatApp(Xs, Ar, H) = if Ar [H] <= 0 then < Xs, H > else < drop(Ar [H] , Xs) , H [mapTreeVars(take(Ar [ H ], Xs))] > fi .

 eq treeVar(I) =  qid("V#@$T" + string(I, 10) + ":Exp") .
 op nTreeVars : Nat Nat -> TermList .
 eq nTreeVars(I, 0) = empty .
 eq nTreeVars(I, s(N)) = treeVar(I), nTreeVars(s(I), N) .
 --- red mapTreeVars(take(20, from(0))) .
 op mapTreeVars : NatList -> TermList .
 eq mapTreeVars(nil) = empty .
 eq mapTreeVars((I O)) = treeVar(I) , mapTreeVars(O) .

 ---  red disagreementPos('b['ff.Exp,'X:Exp, 'tt.Exp], 'b['b['tt.Exp,'ff.Exp,'tt.Exp],'b['ff.Exp,'tt.Exp,'tt.Exp],'ff.Exp]) .
--- BIGBUG eq disagreementPos(Left, Pat) = filtDisagree(Left, Pat, intersection(positionsSigma(Left), positionsSigma(Pat))) .
 eq disagreementPos(Left, Pat) = minimalPos(filtDisagree(Left, Pat, intersection(positionsSigma(Left), positions(Pat)))) .
--- filtDisagree(Left, Pat, intersection(positionsSigma(Left), positions(Pat))) .
    eq filtDisagree(Left, Pat, empty) = empty .
    eq filtDisagree(Left, Pat, (P, Ps)) = if root(at(Left, P)) ==  root(at(Pat, P)) then empty else P fi ,  filtDisagree(Left, Pat, Ps) .

 --- red DPl('tt.Exp ; 'ff.Exp, 'b['tt.Exp,'ff.Exp,'X:Exp], 'b['b['tt.Exp,'ff.Exp,'tt.Exp],'b['ff.Exp,'tt.Exp,'tt.Exp],'ff.Exp]) .
 --- red DPl('tt.Exp ; 'ff.Exp, 'b['ff.Exp,'X:Exp, 'tt.Exp], 'b['b['tt.Exp,'ff.Exp,'tt.Exp],'b['ff.Exp,'tt.Exp,'tt.Exp],'ff.Exp]) .
 --- red DPl('tt.Exp ; 'ff.Exp, 'b['X:Exp, 'tt.Exp, 'ff.Exp], 'b['b['tt.Exp,'ff.Exp,'tt.Exp],'b['ff.Exp,'tt.Exp,'tt.Exp],'ff.Exp]) .
--- BIGBUG  ceq DPl(CS, Left, Pat) = if | intersection(Ps, (positionsCS(CS, Pat) , positionsVar(Pat))) | == 0 then Ps else empty fi
ceq DPl(CS, Left, Pat) = if | intersection(Ps, positionsCS(CS, Pat)) | == 0 then Ps else empty fi
     if Ps := disagreementPos(Left, Pat) .

 --- red DPR((rl 'b['X:Exp,'t.Exp,'ff.Exp] => 'tt.Exp [none] .) (rl 'b['ff.Exp,'X:Exp,'tt.Exp] => 'tt.Exp [none] .) (rl 'b['tt.Exp,'ff.Exp,'X:Exp] => 'tt.Exp [none] .) ,  'b['b['tt.Exp,'ff.Exp,'tt.Exp],'b['ff.Exp,'tt.Exp,'tt.Exp],'ff.Exp] ) .
 --- red DPR((rl 'b['X:Exp,'t.Exp,'ff.Exp] => 'tt.Exp [none] .) (rl 'b['ff.Exp,'X:Exp,'tt.Exp] => 'tt.Exp [none] .) (rl 'b['tt.Exp,'ff.Exp,'X:Exp] => 'tt.Exp [none] .) (rl 'f['X:Exp] => 'h['X:Exp] [none] .) (rl 'g['X:Exp,'Y:Exp] => 'g['h['X:Exp],'g['f['Y:Exp],'Y:Exp]] [none] .) (rl 'h['z.Exp] => 's['z.Exp] [none] .),  'b['b['tt.Exp,'ff.Exp,'tt.Exp],'b['ff.Exp,'tt.Exp,'tt.Exp],'ff.Exp] ) .
 eq DPR(Rs, Pat) = DPRAux(cs(Rs), Rs, Pat) .
 eq DPRAux(CS, none, Pat) = emptyMS .
 eq DPRAux(CS, (rl Left => T [ AtS ] .) Rs, Pat) = if root(Left) == root(Pat) then setToMultiset(DPl(CS, Left, Pat)) else emptyMS fi . DPRAux(CS, Rs, Pat) .

 --- red DPRm((rl 'b['X:Exp,'t.Exp,'ff.Exp] => 'tt.Exp [none] .) (rl 'b['ff.Exp,'X:Exp,'tt.Exp] => 'tt.Exp [none] .) (rl 'b['tt.Exp,'ff.Exp,'X:Exp] => 'tt.Exp [none] .) (rl 'f['X:Exp] => 'h['X:Exp] [none] .) (rl 'g['X:Exp,'Y:Exp] => 'g['h['X:Exp],'g['f['Y:Exp],'Y:Exp]] [none] .) (rl 'h['z.Exp] => 's['z.Exp] [none] .),  'b['b['tt.Exp,'ff.Exp,'tt.Exp],'b['ff.Exp,'tt.Exp,'tt.Exp],'ff.Exp] ) .
 --- red DPRm( ( rl 'or['X:Exp,'tt.Exp] => 'tt.Exp [none] .) (rl 'or['ff.Exp,'X:Exp] => 'X:Exp [none] .) (rl 'or['tt.Exp,'X:Exp] => 'tt.Exp [none] .), 'or ['or ['tt.Exp, 'ff.Exp], 'or ['tt.Exp, 'ff.Exp] ]) .
 ceq DPRm(Rs, Pat) = filtDPRm(Os, Os, Oss, Rs, cs(Rs), Pat)
   if Oss := DPR(Rs, Pat) /\ Os := multisetToSet(Oss) .
 eq filtDPRm(empty, Ps, Pss, Rs, CS, Pat) = empty .
 eq filtDPRm((O , Os), Ps, Pss, Rs, CS, Pat) = if OkDPRm(O, Ps, Pss, Rs, CS, Pat) then O else empty fi , filtDPRm(Os, Ps, Pss, Rs, CS, Pat) .
    op OkDPRm : NatList Set{Pos} Mset{Pos} RuleSet QidSet Term -> Bool .
      eq OkDPRm(O, Ps, Pss, none, CS, Pat) = false .
      eq OkDPRm(O, Ps, Pss, (rl Left => T [ AtS ] .) Rs, CS, Pat) = if O in DPl(CS, Left, Pat) 
                                                                   then if biggerDPRm(O, Ps, Pss, Left)
                                                                              then true else OkDPRm(O, Ps, Pss, Rs, CS, Pat) fi
                                                                   else OkDPRm(O, Ps, Pss, Rs, CS, Pat) fi .
      op biggerDPRm : NatList Set{Pos} Mset{Pos} Term -> Bool .
       eq biggerDPRm(O, empty, Pss, Left) = true .
       eq biggerDPRm(O, (P,  Ps), Pss, Left) = if (mult(O, Pss) >= mult(P, Pss) or isVar(at(Left, P)))
                                                       then biggerDPRm(O, Ps, Pss, Left)
                                                    else false
                                               fi  .


**** Construyendo el arbol
 ceq MDTMap(M) = MDTMapAux(M, from(0), fs(Rs), arity(Rs), Rs, empty)
   if Rs := getRls(M) .
 op MDTMapAux : Module LazyNatList QidSet Map{Qid, Nat} RuleSet Map{Qid, Mdt} -> Map{Qid, Mdt} .
 eq MDTMapAux(M, Xs, none, Ar, Rs, Tm) = Tm .
 ceq MDTMapAux(M, Xs, (F ; FS), Ar, Rs, Tm) = MDTMapAux(M, Ys, FS, Ar, Rs, insert(F, Tree, Tm))
   if < Ys, Tree > := constructMDTF(M, Xs, Ar, F, Rs) .

   **** Builds the tree for a given function symbol
--- eq constructMDTF(M, Xs, Ar, F, Rs) = constructMDT(M, drop(Ar [F] , Xs), F [mapTreeVars(take(Ar [ F ], Xs))], Rs) .
 ceq constructMDTF(M, Xs, Ar, F, Rs) = constructMDT(M, Ys, Ar, T, rulesOf(F, Rs)) 
   if < Ys, T > := flatApp(Xs, Ar, F) .

   **** Builds the tree for a given call pattern
***(
 ceq constructMDT(M, Xs, Ar, Pat, Rs) = 
       if Rs :: Rule 
         then < Xs, leaf(Pat, Rs) >
         else if rsSize(Ss) > 0
                then constructMDTb(M, Xs, Ar, Pat, Ss, Rs')
                else constructMDTc(M, Xs, Ar, Pat, Rs)
         fi
       fi 
  if < Ss, Rs' > := matchingRules(M, Pat, Rs) .
)
--- eq constructMDT(M, Xs, Ar, Pat, none) = < Xs, empty > .
 ceq constructMDT(M, Xs, Ar, Pat, Rs) = 
    if rsSize(Ss) > 0
        then constructMDTb(M, Xs, Ar, Pat, Ss, Rs')
        else constructMDTc(M, Xs, Ar, Pat, Rs)
    fi
  if < Ss, Rs' > := matchingRules(M, Pat, Rs) [owise] .
    op constructMDTb : Module LazyNatList Map{Qid, Nat} Term RuleSet RuleSet -> Pair{LazyNatList, Mdt} . 
***(
    ceq constructMDTb(M, Xs, Ar, Pat, Ss, Rs) = 
            if rsSize(Rs) > 0 then < Ys , or(mapLeaves(Pat, Ss) Tree) >
                              else < Xs , or(mapLeaves(Pat, Ss)) > fi
      if < Ys , Tree > := constructMDT(M, Xs, Ar, Pat, Rs) .
)
    eq constructMDTb(M, Xs, Ar, Pat, Ss, Rs) = 
            if rsSize(Rs) > 0 then constructMDTb1(M, Xs, Ar, Pat, Ss, Rs)
                              else constructMDTb2(Xs, Pat, Ss) 
            fi [ print "--->constructMDTb, patron " Pat ", matching rules " Ss ", non-mathing rules " Rs ] .

        op constructMDTb1 : Module LazyNatList Map{Qid, Nat} Term RuleSet RuleSet -> Pair{LazyNatList, Mdt} . 
        ceq constructMDTb1(M, Xs, Ar, Pat, Ss, Rs) =  < Ys , or(mapLeaves(Pat, Ss) Tree) >
         if < Ys , Tree > := constructMDT(M, Xs, Ar, Pat, Rs) .

        op constructMDTb2 : LazyNatList Term RuleSet -> Pair{LazyNatList, Mdt} . 
        eq constructMDTb2(Xs, Pat, Ss) = if rsSize(Ss) > 1 then
                                            < Xs , or(mapLeaves(Pat, Ss)) > 
                                         else
                                            < Xs , leaf(Pat, Ss) > fi .

          op mapLeaves : Term RuleSet -> Forest .
          eq mapLeaves(Pat, none) = empty .
          eq mapLeaves(Pat, R Rs) =  leaf(Pat, R) mapLeaves(Pat, Rs) .
        

    op constructMDTc : Module LazyNatList Map{Qid, Nat} Term RuleSet -> Pair{LazyNatList, Mdt} . 
    ceq constructMDTc(M, Xs, Ar, Pat, Rs) = < Ys, branch(Pat, Br) >
      if < Ys , Br > := loopConstructMDTc(M, Xs, Ar, DPRm(Rs, Pat), Pat, Rs) [ print "--->constructMDTc, patron " Pat ", reglas " Rs ] .

      op loopConstructMDTc : Module LazyNatList Map{Qid, Nat} Set{Pos} Term RuleSet -> Pair{LazyNatList, Branch} . 
       eq loopConstructMDTc(M, Xs, Ar, empty, Pat, Rs) = < Xs , empty > .
       ceq loopConstructMDTc(M, Xs, Ar, (O , Os) , Pat, Rs) = < Xs' , < O , For > Br  >
---          if (For |->  Ys ) :=  loopPosConstructMDTc(M, Xs, Ar, consAt(Rs, O), O, Pat, Rs)
                                 --- As we do are one sorted every constructor shares its sort with the others
          if (For |->  Ys ) :=  loopPosConstructMDTc(M, Xs, Ar, cs(getRls(M)), O, Pat, Rs)
              /\  < Xs' ,  Br > := loopConstructMDTc(M, Ys, Ar, Os , Pat, Rs) .     

     --- op loopPosConstructMDTc : Module LazyNatList QidSet NatList Term RuleSet -> Pair{LazyNatList, Forest} .
      op loopPosConstructMDTc : Module LazyNatList Map{Qid, Nat} QidSet NatList Term RuleSet -> Map{Forest, LazyNatList} .  
      eq loopPosConstructMDTc(M, Xs, Ar, none, O, Pat, Rs) = empty |-> Xs .
***(
      ceq loopPosConstructMDTc(M, Xs, Ar, (C ; CS), O, Pat, Rs) = (Tree For) |-> Xs' 
         if < Ys, T > := flatApp(Xs, Ar, C) 
         /\ Pat' := replace(Pat, O, T)
         /\ < Ss, Rs' > := unifyingRules(M, Pat', Rs) 
         /\ < Ys', Tree > := constructMDT(M, Ys, Ar, Pat', Ss) 
         /\ (For |-> Xs') := loopPosConstructMDTc(M, Ys', Ar, CS, O, Pat, Rs) .
)     ceq loopPosConstructMDTc(M, Xs, Ar, (C ; CS), O, Pat, Rs) = 
            if rsSize(Ss) > 0 then loopPosConstructMDTc1(M, Ys, Ar, CS, O, Pat, Rs, Pat', Ss)
                              else loopPosConstructMDTc2(M, Ys, Ar, CS, O, Pat, Rs)
            fi 
         if < Ys, T > := flatApp(Xs, Ar, C) 
         /\ Pat' := replace(Pat, O, T)
         /\ < Ss, Rs' > := unifyingRules(M, Pat', Rs) [ print " loopPosConstructMDTc , patron " Pat' ", constructoras " C " y " CS " y reglas " Rs " unificaron " Ss " y no unificaron " Rs' "\n" ] .

         op loopPosConstructMDTc1 : Module LazyNatList Map{Qid, Nat} QidSet NatList Term RuleSet Term RuleSet -> Map{Forest, LazyNatList} .  
         ceq loopPosConstructMDTc1(M, Ys, Ar, CS, O, Pat, Rs, Pat', Ss) = (Tree For) |-> Xs' 
           if < Ys', Tree > := constructMDT(M, Ys, Ar, Pat', Ss) 
           /\ (For |-> Xs') := loopPosConstructMDTc(M, Ys', Ar, CS, O, Pat, Rs) .
         op loopPosConstructMDTc2 : Module LazyNatList Map{Qid, Nat} QidSet NatList Term RuleSet -> Map{Forest, LazyNatList} .  
         ceq loopPosConstructMDTc2(M, Ys, Ar, CS, O, Pat, Rs) = For |-> Xs' 
           if (For |-> Xs') := loopPosConstructMDTc(M, Ys, Ar, CS, O, Pat, Rs) [ print " loopPosConstructMDTc , quedan " CS ] .

  op rsSize : RuleSet -> Nat .
  eq rsSize(none) = 0 .
  eq rsSize((R Rs)) = 1 + rsSize(Rs) .
  --- ( Left < Pat, ! Left < Pat )
  op matchingRules : Module Term RuleSet -> Pair{RuleSet, RuleSet} .
  eq matchingRules(M, Pat, none) = < none, none > .
  ceq matchingRules(M, Pat, (rl Left => T' [ AtS ] .) Rs) = 
      if metaMatch(M, Left, Pat, nil, 0) == noMatch
           then < Rs' , (rl Left => T' [ AtS ] .) Ss >
           else < (rl Left => T' [ AtS ] .) Rs' , Ss >
      fi 
    if < Rs' , Ss > := matchingRules(M, Pat, Rs) .

   --- ( Unifying  , ! Unifying )
   op unifyingRules : Module Term RuleSet -> Pair{RuleSet, RuleSet} .
   eq unifyingRules(M, Pat, none) = < none, none > .
***(
   ceq unifyingRules(M, Pat, (rl Left => T' [ AtS ] .) Rs) = < (rl apSubst(Sigma, Left) => apSubst(Sigma, T') [ AtS ] .) Rs' , Ss > 
    if { Sigma , I } := metaUnify(M, Left =? Pat, 0, 0)
    /\ < Rs' , Ss > := unifyingRules(M, Pat, Rs) .
)
---   ceq unifyingRules(M, Pat, (rl Left => T' [ AtS ] .) Rs) = < (rl reverseRenaming(TL, Sigma,  Left) => reverseRenaming(TL, Sigma,  T') [ AtS ] .) Rs' , Ss >
   ceq unifyingRules(M, Pat, (rl Left => T' [ AtS ] .) Rs) = < (rl reverseRenamingTotal(Sigma,  Left) => reverseRenamingTotal(Sigma,  T') [ AtS ] .) Rs' , Ss >  
    if { Sigma , I } := metaUnify(M, Left =? Pat, 0, 0)
---    /\ TL := getVars(Pat)
    /\ TL := getVars(Left)  
    /\ < Rs' , Ss > := unifyingRules(M, Pat, Rs) [ print "unificando " Left " y " Pat ] .

   ceq unifyingRules(M, Pat, R Rs) = < Rs' , R Ss >
    if < Rs' , Ss > := unifyingRules(M, Pat, Rs) [owise].

  op consAt : RuleSet NatList -> QidSet .
  eq consAt(none, O) = none .
  ceq consAt((rl Left => T' [ AtS ] .) Rs, O) = if isVar(H) then consAt(Rs, O) else (H ; consAt(Rs, O)) fi
      if H := root(at(Left, O)) .

endfm

view PosRulePair from TRIV to PAIR{Pos, RuleSet} is
 sort Elt to Pair{Pos, RuleSet} .
endv

fmod SEARCH-NODE is
 pr META-TERM .
 
 sort SearchNode .
 
 op <_,_,_> : Term Nat TermList -> SearchNode .
endfm

view SearchNode from TRIV to SEARCH-NODE is
 sort Elt to SearchNode .
endv

***(%
\end{verbatim}
}

The module \texttt{NATURAL-REWRITING} uses the matching definitional trees
described above to evaluate a term.

{\codesize
\begin{verbatim}
%)

fmod NATURAL-REWRITING is
 pr MATCHING-TREE .
 pr LIST{PosRulePair} .
 pr LIST{SearchNode} .
 pr PAIR{Nat, TermList} .
 
 var  M : Module .
 vars Q Q' : Qid .
 vars TL TL' TL'' P : TermList .
 vars F F' : Forest .
 vars T T' : Term .
 var  Ct : Constant .
 var  R : Rule .
 vars RS RS' : RuleSet .
 var  AtS : AttrSet .
 var  N : Nat .
 vars NL NL' : NatList .
 var  A : MDT .
 var  B : Branch .
 var  MQM : Map{Qid, Mdt} .
 var  LPRP : List{PosRulePair} .
 var  LSN : List{SearchNode} .

***(%
\end{verbatim}
}

The function \texttt{natNext} computes, given a module, a term,
and a forest of matching definitional trees, the list of possible
results obtained by evaluating the demanded positions of the term.
In the first case, if the term to be evaluated is a constant, we
look for the possible rules that can be applied to it with the
function \texttt{mt} \cite{escobar04}.

{\codesize
\begin{verbatim}
%)

 op natNext : Module Term -> TermList .
 eq natNext(M, T) = natNext(M, T, MDTMap(M)) .

 op natNext : Module Term Map{Qid, Mdt} -> TermList .
 ceq natNext(M, Ct, MQM) = applyIn(M, Ct, LPRP)
  if LPRP := mt(M, Ct, MQM[Ct], MQM) .

***(%
\end{verbatim}
}

If the function symbol is a constructor, we look for the first argument
that is not a cterm\footnote{If the term is a cterm itself, then no
further evaluation is possible and the case is treated by the \texttt{otherwise}
equation below.}, apply \texttt{natNext} to it and the subterm is replaced by
each one of the result list.

{\codesize
\begin{verbatim}
%)

 ceq natNext(M, Q[TL], MQM) = TL''
  if ctor(getRls(M), Q) /\
     < N, T > := firstNotCterm(M, TL, 1) /\
     TL' := natNext(M, T, MQM) /\
     TL'' := replace(Q[TL], N, TL') .

***(%
\end{verbatim}
}

\noindent where the auxiliar functions are defined as follows:

\begin{itemize}

\item The function \texttt{ctor} checks that the term does not appear
as top symbol of a lefthand side.

{\codesize
\begin{verbatim}
%)

 op ctor : RuleSet Qid -> Bool .
 eq ctor(rl Q[TL] => T [AtS] . RS, Q) = false .
 eq ctor(rl Ct => T [AtS] . RS, Ct) = false .
 eq ctor(RS, Q) = true [owise] .

***(%
\end{verbatim}
}

\item \texttt{firstNotCterm} traverses a list of term looking for the first
one that is a cterm, checked with the (meta)function \texttt{cterm} defined
in Section \ref{subsec:parsing}.

{\codesize
\begin{verbatim}
%)

 op firstNotCterm : Module TermList Nat -> Pair{Nat, TermList} .
 eq firstNotCterm(M, empty, N) = < 1, empty > .
 eq firstNotCterm(M, (T, TL), N) = if getTerm(metaReduce(M, 'cterm[T])) == 'true.Bool
                                   then firstNotCterm(M, TL, s(N))
                                   else < N, T >
                                   fi .

***(%
\end{verbatim}
}

\item \texttt{replace} changes the subterm indicated by the index by each one of
the terms given list.

{\codesize
\begin{verbatim}
%)

 op replace : Term Nat TermList -> TermList .
 op replace* : TermList Nat Term -> TermList .

 eq replace(Q[TL], N, (T, TL')) = Q[replace*(TL, N, T)], replace(Q[TL], N, TL') .
 eq replace(Q[TL], N, empty) = empty .

 eq replace*(empty, N, T) = empty .
 eq replace*((T, TL), s(s(N)), T') = T, replace*(TL, s(N), T') .
 eq replace*((T, TL), 1, T') = T', TL .

***(%
\end{verbatim}
}

\end{itemize}

If the term has a function symbol at top we compute the list of
positions and rules that can be applied by means of the function
\texttt{mt}.

{\codesize
\begin{verbatim}
%)

 ceq natNext(M, Q[TL], MQM) = applyIn(M, Q[TL], LPRP)
  if not ctor(getRls(M), Q) /\
     LPRP := mt(M, Q[TL], MQM[Q], MQM) .

***(%
\end{verbatim}
}

\noindent where \texttt{applyIn} applies the rules given in the list in
the corresponding positions.

{\codesize
\begin{verbatim}
%)
 
 op applyIn : Module Term List{PosRulePair} -> TermList .
 op applyIn : Module Term NatList Qid -> Term .
 op applyIn* : Module TermList NatList Qid -> TermList .

 eq applyIn(M, T, < NL, R > LPRP) = applyIn(M, T, NL, getLabel(R)), applyIn(M, T, LPRP) .
 eq applyIn(M, T, nil) = empty .

 eq applyIn(M, T, nil, Q) = getTerm(metaXapply(M, T, Q, none, 0, unbounded, 0)) .
 eq applyIn(M, Q[TL], NL, Q') = Q[applyIn*(M, TL, NL, Q')] .
 
 eq applyIn*(M, (T, TL), 1 NL, Q) = applyIn(M, T, NL, Q), TL .
 eq applyIn*(M, (T, TL), s(s(N)) NL, Q) = T, applyIn*(M, TL, s(N) NL, Q) .
 
 op getLabel : Rule ~> Qid .
 eq getLabel(rl T => T' [label(Q) AtS] .) = Q .

***(%
\end{verbatim}
}

In other case, the term cannot evolve and the functions returns the empty list
of terms.

{\codesize
\begin{verbatim}
%)

 eq natNext(M, T, MQM) = empty [owise] .

***(%
\end{verbatim}
}

The function \texttt{mt} \cite{escobar04} returns a list of pairs with the
needed positions and the rules that must be applied in each of them. If the
tree is a single leaf, the rule in this leaf must be applied at top.

{\codesize
\begin{verbatim}
%)

 op mt : Module Term MDT Map{Qid, Mdt} -> List{PosRulePair} .
 eq mt(M, T, leaf(T', R), MQM) = < nil, R > .

***(%
\end{verbatim}
}

If the tree is an or node, we check all the possible results from the forest
with the function \texttt{allRulesOr}.

{\codesize
\begin{verbatim}
%)

 eq mt(M, T, or(F), MQM) = allRulesOr(M, T, F, MQM) .

***(%
\end{verbatim}
}

If the tree is a branch node, one of the subterms in the indicated
positions of the term has a constructor symbol at top, and the pattern
of at least one of the trees corresponding to this position matches the
subterm, then we continue with these trees.

{\codesize
\begin{verbatim}
%)

 ceq mt(M, T, branch(T', B), MQM) = mt*(M, T, F, MQM)
  if < NL, F > := firstCtor(M, T, B) .
 
 op mt* : Module Term Forest Map{Qid, Mdt} -> List{PosRulePair} .
 eq mt*(M, T, empty, MQM) = nil .
 eq mt*(M, T, A F, MQM) = mt(M, T, A, MQM) mt*(M, T, F, MQM) .

***(%
\end{verbatim}
}

In other case, the functions selects the first position indicated by the tree,
and continues the search with this term, composing the resulting positions with
the function \texttt{newList}.

{\codesize
\begin{verbatim}
%)

 ceq mt(M, T, branch(T', < NL, F > B), MQM) = newList(NL, LPRP)
  if empty == firstCtor(M, T, B) /\
     LPRP := mt(M, getTerm(T, NL), MQM[root(getTerm(T, NL))], MQM) .
 eq mt(M, T, A, MQM) = nil [owise] .
 
 op newList : NatList List{PosRulePair} -> List{PosRulePair} .
 eq newList(NL, nil) = nil .
 eq newList(NL, < NL', R > LPRP) = < NL NL', R > newList(NL, LPRP) .

***(%
\end{verbatim}
}



{\codesize
\begin{comment}
%)

 op allRulesOr : Module Term Forest Map{Qid, Mdt} -> List{PosRulePair} .
 eq allRulesOr(M, T, empty, MQM) = nil .
 eq allRulesOr(M, T, A F, MQM) = mt(M, T, A, MQM) allRulesOr(M, T, F, MQM) .
 
 op firstCtor : Module Term Branch -> Branch .
 eq firstCtor(M, T, empty) = empty .
 ceq firstCtor(M, T, < NL, F > B) = < NL, F' >
  if ctor(getRls(M), root(getTerm(T, NL))) /\
     F' := getMatchs(M, T, F) /\
     F' =/= empty .
 eq firstCtor(M, T, < NL, F > B) = firstCtor(M, T, B) [owise] .

 op getMatchs : Module Term Forest -> Forest .
 eq getMatchs(M, T, empty) = empty .
 eq getMatchs(M, T, A F) = if metaMatch(M, pattern(A), T, nil, 0) =/= noMatch
                           then A
                           else empty
                           fi
                           getMatchs(M, T, F) .
 
 op getTerm : Term NatList -> Term .
 eq getTerm(T, nil) = T .
 eq getTerm(Q[TL], N NL) = getTerm*(TL, N NL) .
 
 op getTerm* : TermList NatList -> Term .
 eq getTerm*((T, TL), 1 NL) = getTerm(T, NL) .
 eq getTerm*((T, TL), s(s(N)) NL) = getTerm*(TL, s(N) NL) .

 op pattern : MDT -> Term .
 eq pattern(leaf(T, R)) = T .
 eq pattern(or(A F)) = pattern(A) .
 eq pattern(branch(T, B)) = T .

***(%
\end{comment}
}

Finally, another function \verb"natNext", that only receives a
module and the term to be reduced, invokes the function \verb"natNext"
computing first the definitional trees with \verb"MDTMap":

{\codesize
\begin{verbatim}
%)

 op natNext : Module Term -> TermList .
 eq natNext(M, T) = natNext(M, T, MDTMap(M)) .

endfm

***(%
\end{verbatim}
}
%)

