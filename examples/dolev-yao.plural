(plural DOLEV-YAO is
--- enc is the data constructor for encoding
 encrypt(M, K) -> enc(M, K) .

--- decrypts messages, using a ground simulation of
--- the equality constraint
--- inv is the  data constructor for inversing a key
 decrypt(enc(M,k1),inv(k1)) -> M .
 decrypt(enc(M,k2),inv(k2)) -> M .
 decrypt(enc(M,k2),inv(k2)) -> M .

 roles -> alice .
 roles -> bob .

***(
The protocol associates to each participant a set of actions, which are
the answers he or she returns for a given question
)
 protocol(alice,ma1) -> mb1 .
 protocol(alice,ma2) -> mb2 .
--- protocol(bob,mb1) -> ma2 .
 protocol(bob,p(ma1, mb1)) -> ma2 .
 protocol(bob,mb2) -> rb2 .

***(
The following function implements the intruder capabilities model of Dolev-Yao
)
 dolevYao(M) -> M ? dolevYao(dyStep(M) ? M) .
 dyStep(M) -> p(M, M) .
 dyStep(p(M1,M2)) -> M1 ? M2 .
 dyStep(M) -> encrypt(M, M) .
 dyStep(M) -> decrypt(M, M) .

***(
Messages that can be deduced by the intruder from a starting set of messages
)
 discover(M) -> M ? discover (discStep(M) ? M) .
 discStep(M) -> protocol(roles,M) ?  dolevYao(M) .
--- discStep(M) -> protocol(roles,dolevYao(M)) .
--- discStep(M) -> protocol(roles,M) .

***(
Given a starting knowledge (a set of messages) for the intruder, returns true if
he discovers the secret.
)
 attack(M) -> secret(discover(M)) .
---- This function defines the patterns which are considered secrets
 secret(rb2) -> true .
 secret'(ma2) -> true .
 secreta(p(ma1,mb1)) -> true .
endp)

--- (width-first .)
(depth-first .)

***(
(eval attack(ma1) .)
(width-first .)
(depth-first .)
(eval [depth= 40] attack(ma1) .)
(eval [depth= 50] attack(ma1) .)
(eval [depth= 2] attack(ma1) .)

(eval dolevYao(ma1) .)
Maude> (eval protocol(roles, dolevYao(ma1)) .)

Result: mb1
Maude> (more .)
Debug(1)>

(eval [depth= 4] protocol(roles, dolevYao(ma1)) .)
Result: mb1

Maude> (more .)

No more results.



 (width-first .)

Maude> (eval [depth= 5] protocol(roles, dolevYao(ma1)) .)

Result: mb1

(eval [depth= 5] discover(ma1) .)


en prof desde luego no va:
Maude> (eval [depth= 5] discover(ma1) .)

Result: ma1

Maude> (more .)

No more results.

Maude> (eval [depth= 4] protocol(roles, dolevYao(mb1)) .)

Result: ma2

Maude> (eval [depth= 4] protocol(roles, dolevYao(ma2)) .)

Result: mb2

Maude> (eval [depth= 4] protocol(roles, dolevYao(mb2)) .)

Result: rb2

Maude> (eval [depth= 12] attack(mb2) .)

Result:(true).Exp

Maude> (eval [depth= 30] attack(ma2) .)

Result:(true).Exp

(eval [depth= 30] attack(ma1 ? mb1) .)

Maude> (eval [depth= 20] dolevYao(ma1 ? mb1) .)

...

Result: p(ma1,mb1)

(eval [depth= 25] discover(ma1) .)

...


p(ma1,mb1)


Maude> (eval [depth= 25] protocol(roles, discover(ma1)) .)

...

Result: ma2

Maude> (eval [depth= 27] secreta(discover(ma1)) .)

Result:(true).Exp

(width-first .)
secret'(ma2) -> true .
Maude>  (eval [depth= 30] secret'(protocol(roles, discover(ma1))) .)

Result:(true).Exp


)


