---- load meta.plural

(plural EXAM is

-------------------------------

***(
Renombrar 'one' a 'any' en meta tb? Parece apropiado?
)

   any is singular .
   any(cons(X, Xs)) -> X ? any(Xs) .

   someElems(Xs) -> nil .
   someElems(cons(X, Xs)) -> cons(X, someElems(Xs)) .
   someElems(cons(X, Xs)) ->  someElems(Xs) .
--------------------------------------------------------------

  add is singular .
  add(z, X) -> X .
  add(s(N), M) -> s(add(N, M)) .
  sum(nil) -> zero .
  sum(cons(X, Xs)) -> add(X, sum(Xs)) .

***(
A ver si el mismo truco se puede hacer aunque sean listas en vez de valores indeterministas
  team1 -> pepe ? loli ? manolo ? juani .
  subjects1 -> knows(pepe, t1.1 ? t1.3) 
             ? knows(loli, t1.2 ? t3)
             ? knows(manolo, t1.2 ? t3) .
)
---  knows(Team, Knowledge, Subject) -> if
  ---- (eval answer(any(team1), any(subjects1)) .)
  ---- (eval answer(any(team1), any(cons(knows(loli, cons(t6, nil)), subjects1))) .)
  answer(Student, knows(S, Subject)) -> if eq(Student, S) then any(Subject) .
  team1 -> cons(pepe, cons(loli, cons(manolo, cons(juani, nil)))) .
  subjects1 -> cons(knows(pepe, cons(t1.1, cons(t1.3, nil)))
              , cons(knows(loli, cons(t1.2, cons(t3, nil)))
              , cons(knows(manolo, cons(t2.1, cons(t4, nil)))
              , nil ))) .

  eq(pepe, pepe) -> tt .
  eq(loli, loli) -> tt .
  eq(manolo, manolo) -> tt .
  eq(juani, juani) -> tt .
  eq(t1.1, t1.1) -> tt .
  eq(t1.2, t1.2) -> tt .
  eq(t2.1, t2.1) -> tt .
  eq(t1.3, t1.3) -> tt .
  eq(t3.1, t3.1) -> tt .
  eq(t3, t3) -> tt .
  eq(t4, t4) -> tt .
  eq(t6, t6) -> tt .
  eq(t5, t5) -> tt .

  knowsAll is plural .
  knowsAll(nil, K) -> tt .
  knowsAll(cons(K1, Ks), K) -> if eq(K, K1) then knowsAll(Ks, K)  .

  mark is plural .
  mark(q1, K) -> if knowsAll(cons(t1.1, cons(t1.2, nil)), K) then s(z) .
  mark(q2, K) -> if knowsAll(cons(t2.1, cons(t1.3, nil)), K) then s(z) .
  mark(q3, K) -> if knowsAll(cons(t3.1, cons(t1.3, nil)), K) then s(z) .
  mark(q4, K) -> if knowsAll(cons(t3, nil), K) then s(z) .
  mark(q5, K) -> if knowsAll(cons(t4, nil), K) then s(z) .


  markAll is plural .
  markAll(nil, K) -> nil .
  markAll(cons(Q, Qs), K) -> cons(mark(Q, K), markAll(Qs, K)) .

  ---- *Main> (filter (/= '"')) $ l2cons ["q"++(show n) | n <- [1..5]]
   exam -> cons(q1 ,cons(q2 ,cons(q3 ,cons(q4 ,cons(q5 ,nil))))) .

   --- (eval passes(exam, team1, subjects1) .)
   passes is singular .
   passes(Exam, Team, Studies) -> minMark(examinate(someElems(Exam), Team, Studies)) .
---  putStrLn $ foldr (\_ -> \xs -> "s(" ++ xs ++ ")") "N" [1..5]
---   minMark(Exam, s(s(s(s(s(N)))))) -> Exam .
   minMark(p(Exam, s(s(N)))) -> Exam .

   --- (eval examinate(someElems(exam), team1, subjects1) .)
   examinate is singular .
   examinate(Exam, Team, Studies) -> p(Exam, sum(markAll(Exam, answer(any(Team), any(Studies))))) .

endp)
